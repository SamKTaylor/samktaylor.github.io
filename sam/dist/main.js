/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/heap/index.js":
/*!************************************!*\
  !*** ./node_modules/heap/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/heap */ \"./node_modules/heap/lib/heap.js\");\n\n\n//# sourceURL=webpack:///./node_modules/heap/index.js?");

/***/ }),

/***/ "./node_modules/heap/lib/heap.js":
/*!***************************************!*\
  !*** ./node_modules/heap/lib/heap.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (true) {\n      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/heap/lib/heap.js?");

/***/ }),

/***/ "./src/common/adventure-finder.js":
/*!****************************************!*\
  !*** ./src/common/adventure-finder.js ***!
  \****************************************/
/*! exports provided: find_path, initialize_graph */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"find_path\", function() { return find_path; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initialize_graph\", function() { return initialize_graph; });\n/* harmony import */ var heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! heap */ \"./node_modules/heap/index.js\");\n/* harmony import */ var heap__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(heap__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst GRAPH_RESOLUTION = 1;\n\nclass Box {\n    constructor(x1, y1, x2, y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    width() {\n        return this.x2 - this.x1;\n    }\n\n    height() {\n        return this.y2 - this.y1;\n    }\n\n    contains(x, y) {\n        return (this.x1 < x && x < this.x2 &&\n                this.y1 < y && y < this.y2);\n    }\n\n    intersects(box) {\n        return (this.x1 <= box.x2 &&\n                box.x1 <= this.x2 &&\n                this.y1 <= box.y2 &&\n                box.y1 <= this.y2);\n    }\n\n    intersects_segment(ox, oy, invdx, invdy) {\n        let t1 = (this.x1 - ox) * invdx;\n        let t2 = (this.x2 - ox) * invdx;\n        let t3 = (this.y1 - oy) * invdy;\n        let t4 = (this.y2 - oy) * invdy;\n\n        let tmin = Math.max(Math.min(t1, t2), Math.min(t3, t4));\n        let tmax = Math.min(Math.max(t1, t2), Math.max(t3, t4));\n\n        if (tmax < 0) return false;\n        if (tmax > 1 || tmin > tmax) return false;\n\n        return true;\n    }\n\n    static square(cx, cy, side) {\n        let half_side = side / 2;\n        return new Box(cx - half_side, cy - half_side, cx + half_side, cy + half_side);\n    }\n}\n\n\nclass NodeTree {\n    constructor(region, obstacles, root, level) {\n        if (!level) {\n            this.level = Math.ceil(Math.log2(region.width() / GRAPH_RESOLUTION));\n        } else {\n            this.level = level;\n        }\n\n        if (root) {\n            this.root = root;\n        } else {\n            this.root = this;\n        }\n\n        this.region = region;\n\n        this.x = (region.x1 + region.x2) / 2;\n        this.y = (region.y1 + region.y2) / 2;\n\n        this.obstacles = obstacles;\n\n        this.crossable = true;\n        this.is_leaf = false;\n\n        if (this.obstacles.length == 0) {\n            this.is_leaf = true;\n        } else if (this.level == 0) {\n            this.is_leaf = true;\n            this.crossable = false;\n        }\n\n        this.quads = null;\n        this.neighbors = null;\n\n        this.list_id = 0;\n        this.heuristic = 0;\n\n        if (!this.is_leaf) {\n            this.subdivide();\n        }\n    }\n\n    get_quad(x, y) {\n        if (x < this.x && y < this.y) return this.quads[0];\n        else if (x >= this.x && y < this.y) return this.quads[1];\n        else if (x < this.x && y >= this.y) return this.quads[2];\n        return this.quads[3];\n    }\n\n    subdivide() {\n        this.quads = [];\n\n        let l = this.region.x1;\n        let r = this.region.x2;\n        let t = this.region.y1;\n        let b = this.region.y2;\n\n        let x = this.x;\n        let y = this.y;\n\n        let subregions = [\n            new Box(l, t, x, y),\n            new Box(x, t, r, y),\n            new Box(l, y, x, b),\n            new Box(x, y, r, b),\n        ];\n\n        let obstacles = this.obstacles;\n        for (let i = 0; i < subregions.length; i++) {\n            let subregion = subregions[i];\n            let subregion_obstacles = [];\n\n            for (let j = 0; j < obstacles.length; j++) {\n                let obstacle = obstacles[j];\n                if (subregion.intersects(obstacle)) {\n                    subregion_obstacles.push(obstacle);\n                }\n            }\n\n            this.quads[i] = new NodeTree(subregion, subregion_obstacles, this.root, this.level - 1);\n        }\n    }\n\n    get(x, y) {\n        if (!this.region.contains(x, y)) return null;\n        if (this.is_leaf) return this;\n        return this.get_quad(x, y).get(x, y);\n    }\n\n    get_neighbors() {\n        if (!this.is_leaf) throw new Error('Tried getting neighbors of non-leaf node');\n        if (this.neighbors) return this.neighbors;\n\n        let left = this.region.x1;\n        let right = this.region.x2;\n        let top = this.region.y1;\n        let bottom = this.region.y2;\n\n        let min_size = this.region.width() * (2 ** -this.level);\n        let num_neighbors = 2 ** this.level;\n\n        let neighbor_set = new Set();\n\n        // Top and bottom (and corners).\n        for (let x = -(num_neighbors + 1); x <= (num_neighbors + 1); x += 2) {\n            let real_x = this.x + min_size * (x / 2);\n\n            let neighbor = this.root.get(real_x, top - min_size / 2);\n            if (neighbor && neighbor.crossable) neighbor_set.add(neighbor);\n\n            neighbor = this.root.get(real_x, bottom + min_size / 2);\n            if (neighbor && neighbor.crossable) neighbor_set.add(neighbor);\n        }\n\n        // Left and right.\n        for (let y = -(num_neighbors - 1); y <= (num_neighbors - 1); y += 2) {\n            let real_y = this.y + min_size * (y / 2);\n\n            let neighbor = this.root.get(left - min_size / 2, real_y);\n            if (neighbor && neighbor.crossable) neighbor_set.add(neighbor);\n\n            neighbor = this.root.get(right + min_size / 2, real_y);\n            if (neighbor && neighbor.crossable) neighbor_set.add(neighbor);\n        }\n\n        this.neighbors = [...neighbor_set];\n\n        return this.neighbors;\n    }\n\n    get_containing(a, b) {\n        if (this.is_leaf) return this;\n\n        let a_quad = this.get_quad(a.x, a.y);\n        let b_quad = this.get_quad(b.x, b.y);\n\n        if (a_quad == b_quad) return a_quad.get_containing(a, b);\n\n        return this;\n    }\n\n    has_sight(node) {\n        let ancestor = this.root.get_containing(this, node);\n        let obstacles = ancestor.obstacles;\n\n        let min_x = Math.min(node.x, this.x);\n        let max_x = Math.max(node.x, this.x);\n        let min_y = Math.min(node.y, this.y);\n        let max_y = Math.max(node.y, this.y);\n\n        let invdx = 1 / (node.x - this.x);\n        let invdy = 1 / (node.y - this.y);\n\n        for (let i = 0; i < obstacles.length; i++) {\n            let obstacle = obstacles[i];\n            if (max_x >= obstacle.x1 && min_x <= obstacle.x2 &&\n                max_y >= obstacle.y1 && min_y <= obstacle.y2 &&\n                obstacle.intersects_segment(this.x, this.y, invdx, invdy)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\nclass VirtualNode extends NodeTree {\n    constructor(parent, x, y) {\n        super(parent.region, [], parent.root, -1);\n\n        this.x = x;\n        this.y = y;\n\n        this.parent = parent;\n        this.neighbors = [parent];\n\n        let neighbors = parent.get_neighbors();\n\n        for (let neighbor of neighbors) {\n            if (!neighbor.has_sight(this)) continue;\n            this.neighbors.push(neighbor);\n            neighbor.get_neighbors().push(this);\n        }\n\n        neighbors.push(this);\n    }\n\n    destroy() {\n        for (let neighbor of this.neighbors) {\n            let neighbor_neighbors = neighbor.get_neighbors();\n            neighbor_neighbors.splice(neighbor_neighbors.indexOf(this), 1);\n        }\n    }\n}\n\nfunction distance(a, b) {\n    let x_dist = b.x - a.x;\n    let y_dist = b.y - a.y;\n    return Math.sqrt(x_dist * x_dist + y_dist * y_dist);\n}\n\nlet list_id = 0;\nfunction find_path(source, target) {\n    /* eslint func-names:0, prefer-arrow-callback:0, no-var:0, vars-on-top:0 */\n    list_id += 2;\n    var closed_id = list_id - 1;\n    var open_id = list_id;\n\n    var open = new heap__WEBPACK_IMPORTED_MODULE_0___default.a(function (a, b) { return a.heuristic - b.heuristic; });\n\n    var traveled = new Map();\n    var parents = new Map();\n\n    traveled.set(source, 0);\n    parents.set(source, source);\n\n    source.heuristic = distance(source, target);\n    open.push(source);\n    source.list_id = open_id;\n\n    while (open.size()) {\n        var current = open.pop();\n        var parent = parents.get(current);\n        let neighbors = current.get_neighbors();\n\n        if (!parent.has_sight(current)) {\n            let min_path = Infinity;\n            let fastest_neighbor = null;\n            for (let neighbor of neighbors) {\n                if (neighbor.list_id == closed_id) {\n                    let path = traveled.get(neighbor) + distance(neighbor, current);\n                    if (path < min_path) {\n                        min_path = path;\n                        fastest_neighbor = neighbor;\n                    }\n                }\n            }\n\n            parents.set(current, fastest_neighbor);\n            traveled.set(current, min_path);\n\n            parent = fastest_neighbor;\n        }\n\n        if (current == target) {\n            break;\n        }\n\n        current.list_id = closed_id;\n\n        for (var i = 0; i < neighbors.length; i++) {\n            var neighbor = neighbors[i];\n\n            if (neighbor.list_id == closed_id) continue;\n\n            var old_path = traveled.get(neighbor) || Infinity;\n\n            var new_path = traveled.get(parent) + distance(parent, neighbor);\n            if (new_path < old_path) {\n                traveled.set(neighbor, new_path);\n                parents.set(neighbor, parent);\n\n                neighbor.heuristic = new_path + distance(neighbor, target);\n                if (neighbor.list_id == open_id) {\n                    open.updateItem(neighbor);\n                } else {\n                    open.push(neighbor);\n                    neighbor.list_id = open_id;\n                }\n            }\n        }\n    }\n\n    if (!parents.has(target)) return [];\n\n    var path = [];\n    var node = target;\n    while (node && node != source) {\n        path.unshift(node);\n        node = parents.get(node);\n    }\n\n    return path;\n}\n\nfunction calculate_size(actual_size) {\n    let cur_size = GRAPH_RESOLUTION;\n\n    while (cur_size < actual_size) {\n        cur_size *= 2;\n    }\n\n    return cur_size;\n}\n\nfunction initialize_graph(map_name) {\n    let map_data = parent.G.maps[map_name].data;\n\n    let min_x = Infinity;\n    let max_x = -Infinity;\n    let min_y = Infinity;\n    let max_y = -Infinity;\n\n\n    let obstacles = [];\n\n    for (let line of map_data.x_lines) {\n        min_x = Math.min(min_x, line[0]);\n        max_x = Math.max(max_x, line[0]);\n        obstacles.push(new Box(\n            line[0] - 8,\n            line[1] - 8,\n            line[0] + 8,\n            line[2] + 12\n        ));\n    }\n\n    for (let line of map_data.y_lines) {\n        min_y = Math.min(min_y, line[0]);\n        max_y = Math.max(max_y, line[0]);\n        obstacles.push(new Box(\n            line[1] - 8,\n            line[0] - 8,\n            line[2] + 8,\n            line[0] + 12\n        ));\n    }\n\n    console.log(obstacles);\n\n    let largest_side = Math.max(max_x - min_x, max_y - min_y);\n    let side = calculate_size(largest_side);\n\n    let center_x = (max_x + min_x) / 2;\n    let center_y = (max_y + min_y) / 2;\n    let region = Box.square(center_x, center_y, side);\n\n    return new NodeTree(region, obstacles);\n}\n\n\n//# sourceURL=webpack:///./src/common/adventure-finder.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _common_adventure_finder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/adventure-finder */ \"./src/common/adventure-finder.js\");\n\n\nvar sams_node_tree = Object(_common_adventure_finder__WEBPACK_IMPORTED_MODULE_0__[\"initialize_graph\"])(\"main\");\n\nconsole.log(sams_node_tree);\n\nconst TEST_LOCATIONS = [\n    {\"x\": 614,\"y\": 663,\"map\": \"main\", name: \"mansion enterance\"},\n    {\"x\": 108,\"y\": 793,\"map\": \"main\", name: \"spawn\"},\n    {\"x\": 0,\"y\": 0,\"map\": \"main\", name: \"town\"},\n    {\"x\": -1195,\"y\": -156,\"map\": \"main\", name: \"crabs\"},\n    {\"x\": 476,\"y\": 1927,\"map\": \"main\", name: \"armadillos\"},\n    {\"x\": -850,\"y\": 1880,\"map\": \"main\", name: \"huge crabs\"},\n    {\"x\": -1499,\"y\": 585,\"map\": \"main\", name: \"pier\"},\n    //{\"x\": 1381,\"y\": 160,\"map\": \"main\", name: \"cave of darkness entrance\"},\n    {\"x\": -705,\"y\": 1147,\"map\": \"main\", name: \"pets\"},\n    {\"x\": -1195,\"y\": -156,\"map\": \"main\", name: \"crabs2\"},\n    {\"x\": 614,\"y\": 663,\"map\": \"main\", name: \"mansion enterance2\"},\n]\n\n\nconst TEST_LOCATION_1 = {\n    \"x\": 614,\n    \"y\": 663,\n    \"map\": \"main\"\n};\n\nconst TOWN = {\n    \"min_x\": -100,\n    \"max_x\": 100,\n    \"min_y\": -100,\n    \"max_y\": 100,\n    \"map\": \"main\"\n};\n\nvar state = \"CalculateMovement\"\nvar path_checklist = null;\nvar failures = 0;\nvar move_failures = 0;\nvar move_index = 0;\n\nsetInterval(function () {\n    //set_message(state);\n\n    if (!is_on_cooldown(\"regen_hp\") && character.hp < character.max_hp - 100) {\n        use_skill(\"regen_hp\");\n    }\n\n    if (is_moving(character)) return;\n\n    switch(state) {\n        case \"Traverse\":\n            TRAVERSE(\"CalculateMovement\");\n            break;\n        case \"Town\":\n            if(character.real_x > TOWN.min_x && character.real_x < TOWN.max_x && character.real_y > TOWN.min_y && character.real_y < TOWN.max_y){\n                state = \"CalculateMovement\";\n                //set_message(state);\n            }else{\n                use_skill(\"use_town\");\n            }\n\n            break;\n\n        case \"CalculateMovement\":\n            var test_location = Math.floor(Math.random() * 10);\n            set_message(TEST_LOCATIONS[test_location].name);\n            CALCULATE_MOVEMENT(TEST_LOCATIONS[test_location].x, TEST_LOCATIONS[test_location].y);\n            break;\n\n        default:\n          // code block\n      } \n\n\n}, 1000 / 4); // Loops every 1/4 seconds.\n\nconst CALCULATE_MOVEMENT = (x,y) => {\n\n    log(\"Looking for path\");\n    var path = get_path(x,y);\n    \n    if(path.length == 0){\n        log(\"No result found.\");\n        //no result, try smart move\n        console.log(path);\n        smart_move(x, y);\n\n    }else if(path.length == 1){\n        log(\"Only one result, just moving there.\");\n        //1 result, just go there.\n        move(path[0].x, path[0].y);\n\n    }else{\n        log(\"Creating checklist.\");\n        path_checklist = create_path_checklist(path);\n\n        render_path(path_checklist);        \n        move_index = 0;\n        state = \"Traverse\"\n        //set_message(state);\n        failures = 0;\n    }\n}\n\nconst TRAVERSE = (DONE_STATE) => {\n\n    console.log(path_checklist);\n    //find next distination in list we have reached desired location\n    var i;\n    for (i = 0; i < path_checklist.length; i++) {\n        if(path_checklist[i].visited == false){\n            move_index = i;\n            log('Next target ' + path_checklist[move_index].x + ',' + path_checklist[move_index].y + '.');\n            break;\n        }\n    } \n\n    console.log(path_checklist[move_index]);\n\n    //are we there yet\n    if(path_checklist[move_index].x == character.real_x && path_checklist[move_index].y == character.real_y){\n        path_checklist[move_index].visited = true;\n        move_failures = 0;\n        log('Target ' + path_checklist[move_index].x + ',' + path_checklist[move_index].y + ' reached.');\n\n        move_index++;\n\n        if(typeof path_checklist[move_index] === 'undefined'){\n            log(\"End of path.\");\n            state = DONE_STATE;\n            set_message(state);\n            move_index = 0;\n            return;\n        }else{\n            log('Next target ' + path_checklist[move_index].x + ',' + path_checklist[move_index].y + '.');\n        }\n    }else{\n        //stoped mid path?\n        log(\"Not there yet. I'm at: \" + character.x + \",\" + character.y);\n        move_failures++\n    }\n\n    console.log(path_checklist[move_index]);\n\n    if(move_failures > 10){\n        //stuck?\n        try_unstuck();\n        move_failures = 0;\n    }else{\n        move(path_checklist[move_index].x, path_checklist[move_index].y);\n        log(\"Moving \" + move_index);\n    }\n\n}\n\nconst get_path = (x,y) => {\n\n    var source = sams_node_tree.get(character.x, character.y);\n    var target = sams_node_tree.get(x,y);\n\n    return Object(_common_adventure_finder__WEBPACK_IMPORTED_MODULE_0__[\"find_path\"])(source, target);\n \n}\n\nconst get_furthest_entirty = () => {\n\n    var furthest = null;\n\n    for (var id in parent.entities) {\n\n        var current = parent.entities[id];\n            \n        if (furthest != null) {\n            if (distanceFrom(current.x, current.y) > distanceFrom(furthest.x, furthest.y)) {\n                furthest = current;\n            }\n        } else {\n            furthest = current;\n        }\n    }\n\n    return furthest;\n\n}\n\nconst create_path_checklist = (path) => {\n\n    var path_checklist = [];\n\n    path.forEach((node) => {\n        path_checklist.push({x: node.x, y: node.y, visited: false});\n    });\n\n    return path_checklist;\n}\n\nconst try_unstuck = () => {\n\n    log(\"Trying unstuck.\");\n    var jitter_x = character.x + ((Math.floor(Math.random() * 100) + 1) - 50);\n    var jitter_y = character.y + ((Math.floor(Math.random() * 100) + 1) - 50);\n\n    draw_line(character.x,character.y,jitter_x,jitter_y, 1, 0xFF0000);\n\n    move(jitter_x, jitter_y);\n\n}\n\nconst distanceFrom = (x, y) => {\n    return Math.abs(Math.sqrt(\n        Math.pow(x - character.real_x, 2) + Math.pow(y - character.real_y, 2)\n    ));\n};\n\nconst render_path = (path) => {\n    log(\"Drawing path checklist.\");\n    draw_line(character.x, character.y,path[0].x,path[0].y, 1, 0x0033FF);\n    var i;\n    for (i = 0; i < path.length - 1; i++) {\n        draw_line(path[i].x,path[i].y,path[i+1].x,path[i+1].y, 1, 0x0033FF);\n    } \n}\n\n/*\nfunction draw_all_quads(node){\n\n    if(node.quads != null){\n\n        node.quads.forEach((quad) => {\n\n            setTimeout(() => draw_all_quads(quad), 100);\n\n            if(quad.is_leaf == true && quad.crossable == true){\n                quad.get_neighbors().forEach((neighbor) => {\n                    console.log(\"Drawing line\")\n                    draw_line(quad.x,quad.y,neighbor.x,neighbor.y, 1, 0x0033FF);\n                });\n            }\n        });\n\n    }else{\n        return;\n    }\n}*/\n\n//draw_all_quads(sams_node_tree);\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });